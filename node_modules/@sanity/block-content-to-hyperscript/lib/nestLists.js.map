{"version":3,"sources":["../src/nestLists.js"],"names":["objectAssign","require","nestLists","blocks","mode","tree","currentList","i","length","block","isListBlock","push","listFromBlock","blockMatchesList","children","level","newList","lastListItem","lastChild","newLastChild","concat","match","findListMatching","listItem","console","warn","Boolean","list","_type","_key","rootNode","matching","filterOnType","node","module","exports"],"mappings":"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","sourcesContent":["const objectAssign = require('object-assign')\n\n/* eslint-disable max-depth, complexity */\nfunction nestLists(blocks, mode = 'html') {\n  const tree = []\n  let currentList\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i]\n    if (!isListBlock(block)) {\n      tree.push(block)\n      currentList = null\n      continue\n    }\n\n    // Start of a new list?\n    if (!currentList) {\n      currentList = listFromBlock(block)\n      tree.push(currentList)\n      continue\n    }\n\n    // New list item within same list?\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block)\n      continue\n    }\n\n    // Different list props, are we going deeper?\n    if (block.level > currentList.level) {\n      const newList = listFromBlock(block)\n\n      if (mode === 'html') {\n        // Because HTML is kinda weird, nested lists needs to be nested within list items\n        // So while you would think that we could populate the parent list with a new sub-list,\n        // We actually have to target the last list element (child) of the parent.\n        // However, at this point we need to be very careful - simply pushing to the list of children\n        // will mutate the input, and we don't want to blindly clone the entire tree.\n\n        // Clone the last child while adding our new list as the last child of it\n        const lastListItem = lastChild(currentList)\n        const newLastChild = objectAssign({}, lastListItem, {\n          children: lastListItem.children.concat(newList)\n        })\n\n        // Swap the last child\n        currentList.children[currentList.children.length - 1] = newLastChild\n      } else {\n        currentList.children.push(newList)\n      }\n\n      // Set the newly created, deeper list as the current\n      currentList = newList\n      continue\n    }\n\n    // Different list props, are we going back up the tree?\n    if (block.level < currentList.level) {\n      // Current list has ended, and we need to hook up with a parent of the same level and type\n      const match = findListMatching(tree[tree.length - 1], block)\n      if (match) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      }\n\n      // Similar parent can't be found, assume new list\n      currentList = listFromBlock(block)\n      tree.push(currentList)\n      continue\n    }\n\n    // Different list props, different list style?\n    if (block.listItem !== currentList.listItem) {\n      const match = findListMatching(tree[tree.length - 1], {level: block.level})\n      if (match && match.listItem === block.listItem) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      } else {\n        currentList = listFromBlock(block)\n        tree.push(currentList)\n        continue\n      }\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn('Unknown state encountered for block', block)\n    tree.push(block)\n  }\n\n  return tree\n}\n\nfunction isListBlock(block) {\n  return Boolean(block.listItem)\n}\n\nfunction blockMatchesList(block, list) {\n  return block.level === list.level && block.listItem === list.listItem\n}\n\nfunction listFromBlock(block) {\n  return {\n    _type: 'list',\n    _key: `${block._key}-parent`,\n    level: block.level,\n    listItem: block.listItem,\n    children: [block]\n  }\n}\n\nfunction lastChild(block) {\n  return block.children && block.children[block.children.length - 1]\n}\n\nfunction findListMatching(rootNode, matching) {\n  const filterOnType = typeof matching.listItem === 'string'\n  if (\n    rootNode._type === 'list' &&\n    rootNode.level === matching.level &&\n    (filterOnType && rootNode.listItem === matching.listItem)\n  ) {\n    return rootNode\n  }\n\n  const node = lastChild(rootNode)\n  if (!node) {\n    return false\n  }\n\n  return findListMatching(node, matching)\n}\n\nmodule.exports = nestLists\n"],"file":"nestLists.js"}