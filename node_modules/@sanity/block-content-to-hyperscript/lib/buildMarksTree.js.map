{"version":3,"sources":["../src/buildMarksTree.js"],"names":["defaultMarks","buildMarksTree","block","children","markDefs","length","sortedMarks","map","sortMarksByOccurences","rootNode","_type","nodeStack","forEach","span","i","marksNeeded","lastNode","push","pos","mark","markKey","index","indexOf","splice","slice","currentNode","findLastParentNode","node","_key","find","def","isTextSpan","lines","text","split","line","concat","spans","marks","markOccurences","reduce","occurences","siblingIndex","sibling","Array","isArray","sortByOccurence","sortMarks","bind","sort","markA","markB","aOccurences","bOccurences","aDefaultPos","bDefaultPos","nodes","undefined","module","exports"],"mappings":"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","sourcesContent":["const defaultMarks = ['strong', 'em', 'code', 'underline', 'strike-through']\n\nconst buildMarksTree = block => {\n  const {children, markDefs} = block\n  if (!children || !children.length) {\n    return []\n  }\n\n  const sortedMarks = children.map(sortMarksByOccurences)\n  const rootNode = {_type: 'span', children: []}\n  let nodeStack = [rootNode]\n\n  children.forEach((span, i) => {\n    const marksNeeded = sortedMarks[i]\n    if (!marksNeeded) {\n      const lastNode = nodeStack[nodeStack.length - 1]\n      lastNode.children.push(span)\n      return\n    }\n\n    let pos = 1\n\n    // Start at position one. Root is always plain and should never be removed. (?)\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        const mark = nodeStack[pos].markKey\n        const index = marksNeeded.indexOf(mark)\n        // eslint-disable-next-line max-depth\n        if (index === -1) {\n          break\n        }\n\n        marksNeeded.splice(index, 1)\n      }\n    }\n\n    // Keep from beginning to first miss\n    nodeStack = nodeStack.slice(0, pos)\n\n    // Add needed nodes\n    let currentNode = findLastParentNode(nodeStack)\n    marksNeeded.forEach(mark => {\n      const node = {\n        _type: 'span',\n        _key: span._key,\n        children: [],\n        mark: markDefs.find(def => def._key === mark) || mark,\n        markKey: mark\n      }\n\n      currentNode.children.push(node)\n      nodeStack.push(node)\n      currentNode = node\n    })\n\n    // Split at newlines to make individual line chunks, but keep newline\n    // characters as individual elements in the array. We use these characters\n    // in the span serializer to trigger hard-break rendering\n    if (isTextSpan(span)) {\n      const lines = span.text.split('\\n')\n      for (let line = lines.length; line-- > 1; ) {\n        lines.splice(line, 0, '\\n')\n      }\n\n      currentNode.children = currentNode.children.concat(lines)\n    } else {\n      currentNode.children = currentNode.children.concat(span)\n    }\n  })\n\n  return rootNode.children\n}\n\n// We want to sort all the marks of all the spans in the following order:\n// 1. Marks that are shared amongst the most adjacent siblings\n// 2. Non-default marks (links, custom metadata)\n// 3. Built-in, plain marks (bold, emphasis, code etc)\nfunction sortMarksByOccurences(span, i, spans) {\n  if (!span.marks || span.marks.length === 0) {\n    return span.marks || []\n  }\n\n  const markOccurences = span.marks.reduce((occurences, mark) => {\n    occurences[mark] = occurences[mark] ? occurences[mark] + 1 : 1\n\n    for (let siblingIndex = i + 1; siblingIndex < spans.length; siblingIndex++) {\n      const sibling = spans[siblingIndex]\n\n      if (sibling.marks && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) {\n        occurences[mark]++\n      } else {\n        break\n      }\n    }\n\n    return occurences\n  }, {})\n\n  const sortByOccurence = sortMarks.bind(null, markOccurences)\n\n  // Slicing because sort() mutates the input\n  return span.marks.slice().sort(sortByOccurence)\n}\n\nfunction sortMarks(occurences, markA, markB) {\n  const aOccurences = occurences[markA] || 0\n  const bOccurences = occurences[markB] || 0\n\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences\n  }\n\n  const aDefaultPos = defaultMarks.indexOf(markA)\n  const bDefaultPos = defaultMarks.indexOf(markB)\n\n  // Sort default marks last\n  if (aDefaultPos !== bDefaultPos) {\n    return aDefaultPos - bDefaultPos\n  }\n\n  // Sort other marks simply by key\n  if (markA < markB) {\n    return -1\n  } else if (markA > markB) {\n    return 1\n  }\n\n  return 0\n}\n\nfunction isTextSpan(node) {\n  return (\n    node._type === 'span' &&\n    typeof node.text === 'string' &&\n    (Array.isArray(node.marks) || typeof node.marks === 'undefined')\n  )\n}\n\nfunction findLastParentNode(nodes) {\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    const node = nodes[i]\n    if (node._type === 'span' && node.children) {\n      return node\n    }\n  }\n\n  return undefined\n}\n\nmodule.exports = buildMarksTree\n"],"file":"buildMarksTree.js"}